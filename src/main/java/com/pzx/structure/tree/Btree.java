package com.pzx.structure.tree;

/**
 * 参考：https://blog.csdn.net/shenchaohao12321/article/details/83243314
 *
 * M阶B树定义：
 * 1、根结点孩子数量：[2，M]
 * 2、中间结点孩子数量：[ceil(M/2), M]
 * 3、根结点和中间结点的关键字数量：他们的孩子数量 -1
 * 4、一个结点当中：指向孩子指针和关键字的位置关系是：(指针1) 关键字A (指针2) 关键字B (指针3)
 *    每个关键字的值 > 左指针 指向的孩子树里结点中的关键字
 *    每个关键字的值 < 右指针 指向的孩子树里结点中的关键字
 * 5、叶子结点位于同一层
 * 6、结点中的关键字从小到大排列
 * 7、结点中关键字不重复
 *
 * M阶B+树定义：
 * 1、根结点孩子数量：[2，M]
 * 2、中间结点孩子数量：[ceil(M/2), M]
 * 3、根节点和中间结点的孩子数量 = 关键字数量
 * 4、根节点和中间结点的关键字 是 关键字对应子树中所有关键字的最大值，同时也存在于子树中
 * 5、根节点和中间结点只做索引，不包含数据
 * 6、叶子结点包含所有数据，并按照从小到大顺序排列
 * 7、叶子结点用指针连在一起
 * @param <T>
 */
public class Btree<T extends Comparable<? super T>> {


    /**
     * B树和B+树的插入删除特点
     *
     * 插入：
     * 如果插入超出关键字阈值，则将当前节点分裂为两个节点，在父节点中增加一个关键字，重复检查父节点。
     *
     * 删除操作：
     * 1.对于B树首先将删除的非叶子节点中的key替换成后继key（后继key一定在叶子节点中），然后删除后继key，类似于二叉搜索树删除。
     * 2.对于叶子节点删除，如果删除之后低于关键字阈值，判断兄弟节点关键字是否富余，是则借兄弟节点一个key，修改父节点key（B树是父结点key下移，兄弟结点key上移，B+树是直接移动到自己节点中，修改父节点key）
     * 3.如果兄弟节点不富余，则和兄弟节点合并，父节点key减少一个,重复检查父节点。
     */

}
